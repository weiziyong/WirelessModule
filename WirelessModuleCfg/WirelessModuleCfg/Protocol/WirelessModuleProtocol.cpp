//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Untitled
//  @ File Name : CWirelessModuleProtocol.cpp
//  @ Date : 2014/10/29 星期三
//  @ Author :
//
//

#include "stdafx.h"
#include "WirelessModuleProtocol.h"
#include "CfgBaudrateCmd.h"
#include "Communication.h"
#include "CfgCommChannelCmd.h"
#include "CfgTransSpeedCmd.h"
#include "SearchCmd.h"
#include "SearchAckCmdDataParser.h"
#include "Connection.h"
#include "../LogSystem.h"
#include "SendFirmwareCode.h"
#include "ReadFirmwareCode.h"
#include "UpdateFwEnd.h"
#include "CfgMdlNetID.h"


class CWirelessModuleCfgDlg;

CWirelessModuleProtocol::CWirelessModuleProtocol()
{
}

CWirelessModuleProtocol::~CWirelessModuleProtocol()
{

}

BOOL CWirelessModuleProtocol::SendCfgCmd(CCfgProtocol* const pCfgProtocol)
{
    LOG_TRACE_METHORD(TEXT("CWirelessModuleProtocol::SendCfgCmd func."));

    ASSERT(NULL != pCfgProtocol);

    if (!pCfgProtocol->SendCmd())
    {
        return FALSE;
    }

    return TRUE;
}

BOOL CWirelessModuleProtocol::SendCfgBaudRateCmd(CCommIntf* const pCommIntf, const DWORD dwBaudRate)
{
    LOG_TRACE_METHORD(TEXT("CWirelessModuleProtocol::SendCfgBaudRateCmd func."));

    CCfgBaudrateCmd CfgBaudRateCmd(pCommIntf, dwBaudRate);
    if (!SendCfgCmd(&CfgBaudRateCmd))
    {
        LOG_ERROR("Set the device's baudrate to " << dwBaudRate << " bps" << ", failed !");
        return FALSE;
    }

    return TRUE;
}

BOOL CWirelessModuleProtocol::SendCfgChannelNumCmd(CCommIntf* const pCommIntf,
        const BYTE btCommChannelNum)
{
    LOG_TRACE_METHORD(TEXT("CWirelessModuleProtocol::SendCfgChannelNumCmd func."));

    CCfgCommChannelCmd CfgCommChannelCmd(pCommIntf, btCommChannelNum);
    if (!SendCfgCmd(&CfgCommChannelCmd))
    {
        LOG_ERROR("Set the communicational channel num to " << btCommChannelNum << ", failed !");

        return FALSE;
    }

    return TRUE;
}

BOOL CWirelessModuleProtocol::SendCfgTransSpeedCmd(CCommIntf* const pCommIntf,
        const DWORD dwTransSpeed)
{
    LOG_TRACE_METHORD(TEXT("CWirelessModuleProtocol::SendCfgTransSpeedCmd func."));

    CCfgTransSpeedCmd CfgTransSpeedCmd(pCommIntf, dwTransSpeed);
    if (!SendCfgCmd(&CfgTransSpeedCmd))
    {
        CString strLog;
        LOG_ERROR("Set the trans's speed to " << dwTransSpeed << " kbps, failed !");
        return FALSE;
    }

    return TRUE;
}

BOOL CWirelessModuleProtocol::SendSearchCmd(
                CCommIntf* const pCommIntf,
                CCfgInfo& AllCfgInfo)
{
    LOG_TRACE_METHORD(TEXT("CWirelessModuleProtocol::SendSearchCmd func."));

    CSearchCmd SearchCmd(pCommIntf);
    if (!SendCfgCmd(&SearchCmd))
    {
        LOG_ERROR("Send the cmd of search, failed !");
        return FALSE;
    }

    PBYTE pAckCmdData = NULL;
    DWORD dwAckCmdDataLen = 0;
    SearchCmd.GetAckCmdData(pAckCmdData, dwAckCmdDataLen);
    CSearchAckCmdDataParser SearchAckCmdDataParser(pAckCmdData, dwAckCmdDataLen);
    AllCfgInfo.m_dwCurBaudRate = SearchAckCmdDataParser.GetCurBaudrate();
    AllCfgInfo.m_dwMinBaudRate = SearchAckCmdDataParser.GetMinBaudrate();
    AllCfgInfo.m_dwMaxBaudRate = SearchAckCmdDataParser.GetMaxBaudrate();
    AllCfgInfo.m_btCurCommChannelNum = SearchAckCmdDataParser.GetCurCommChannelNum();
    AllCfgInfo.m_btMaxCommChannelNum = SearchAckCmdDataParser.GetMaxCommChannelNum();
    AllCfgInfo.m_dwCurTransSpeed = SearchAckCmdDataParser.GetCurTransSpeed();
    AllCfgInfo.m_dwCurFreq = SearchAckCmdDataParser.GetCurFrequency();
    AllCfgInfo.m_dwDevID = SearchAckCmdDataParser.GetID();
    AllCfgInfo.m_stProductDate = SearchAckCmdDataParser.GetProductDate();
    AllCfgInfo.m_stHardwareVer = SearchAckCmdDataParser.GetHardwareVer();
    AllCfgInfo.m_stSoftwareVer = SearchAckCmdDataParser.GetSoftwareVer();
    AllCfgInfo.m_uProductType = SearchAckCmdDataParser.GetProductType();
    AllCfgInfo.m_sMdlNetID = SearchAckCmdDataParser.GetMdlNetID();

    if (NULL != pAckCmdData)
    {
        delete[] pAckCmdData;
        pAckCmdData = NULL;
    }

    return TRUE;
}

BOOL CWirelessModuleProtocol::SendCfgMdlNetID(CCommIntf* const pCommIntf,
        const USHORT& uMdlNetID)
{
    LOG_TRACE_METHORD(L"CWirelessModuleProtocol::SendCfgMdlNetID func.");

    CCfgMdlNetID cfgMdlNetID(pCommIntf, uMdlNetID);
    if (!SendCfgCmd(&cfgMdlNetID))
    {
        return FALSE;
    }

    return TRUE;
}

BOOL CWirelessModuleProtocol::SendConnectDeviceCmd(
                const DWORD&  dwCurComPortNum,
                USHORT& sDevID,
                USHORT& sPageTotal,
                USHORT& sPageSize)
{
    LOG_TRACE_METHORD(TEXT("CWirelessModuleProtocol::SendConnectDeviceCmd func."));

    CCommunication* pCommIntf = new CCommunication(dwCurComPortNum,
            CProtocolConst::UPDATE_FIRMWARE_BAUDRATE);

    CConnCmd connectDeviceCmd(pCommIntf);
    if (!SendCfgCmd(&connectDeviceCmd))
    {
        LOG_ERROR(TEXT("failed to send the cmd of connecting device."));
        return FALSE;
    }

    PBYTE pAckCmdData = nullptr;
    DWORD dwAckCmdDataLen = 0;
    if (!connectDeviceCmd.GetAckCmdData(pAckCmdData, dwAckCmdDataLen))
    {
        LOG_ERROR("failed to get the ack cmd data of connecting device.");
        return FALSE;
    }

    const DWORD dwCmdDataOffset = CProtocolConst::OFFSET_DEVICE_ID;
    sDevID = pAckCmdData[CProtocolConst::OFFSET_DEVICE_ID - dwCmdDataOffset];

    USHORT uPageTotalHighByte =
                    pAckCmdData[CProtocolConst::OFFSET_PAGE_TOTAL - dwCmdDataOffset];
    USHORT uPageTotalLowByte =
                    pAckCmdData[CProtocolConst::OFFSET_PAGE_TOTAL - dwCmdDataOffset + 1];

    sPageTotal = ((uPageTotalHighByte & 0X00FF) << 8) |
                 (uPageTotalLowByte & 0X00FF);

    USHORT uPageSizeHighByte =
                    pAckCmdData[CProtocolConst::OFFSET_PAGE_SIZE - dwCmdDataOffset];
    USHORT uPageSizeLowByte  =
                    pAckCmdData[CProtocolConst::OFFSET_PAGE_SIZE - dwCmdDataOffset + 1];

    sPageSize = ((uPageSizeHighByte & 0X00FF) << 8) |
                (uPageSizeLowByte & 0X00FF);

    LOG_INFO(TEXT("sPageTotal = ") << sPageTotal <<
             TEXT(", sPageSize = ") << sPageSize);

    if (nullptr != pAckCmdData)
    {
        delete[] pAckCmdData;
        pAckCmdData = nullptr;
    }

    return TRUE;
}

BOOL CWirelessModuleProtocol::SendFWPageCode(
                const DWORD&  dwCurComPortNum,
                const USHORT& sPageNum,
                const UCHAR* pFirmwarePageCode,
                const USHORT& sPageSize)
{
    LOG_TRACE_METHORD(TEXT("CWirelessModuleProtocol::SendFirewarePageCode func."));

    CCommunication* pCommIntf = new CCommunication(dwCurComPortNum,
            CProtocolConst::UPDATE_FIRMWARE_BAUDRATE);

    CSendFirmwareCode firmwareCodeCmd(pCommIntf,
                                      sPageNum,
                                      pFirmwarePageCode,
                                      sPageSize);

    if (!SendCfgCmd(&firmwareCodeCmd))
    {
        LOG_ERROR(TEXT("failed to send the cmd of sending firmware code to device."));
        return FALSE;
    }

    PBYTE pAckCmdData = nullptr;
    DWORD dwAckCmdDataLen = 0;
    if (!firmwareCodeCmd.GetAckCmdData(pAckCmdData, dwAckCmdDataLen))
    {
        LOG_ERROR("failed to get the ack's cmd data of upgrade firmware cmd.");
        return FALSE;
    }

    BOOL bResult = TRUE;
    if (CProtocolConst::FIELD_LEN_WRITE_PAGE_CODE_STATUS !=
            pAckCmdData[CProtocolConst::OFFSET_WRITE_PAGE_CODE -
                                                               CProtocolConst::OFFSET_CMD_DATA])
    {
        bResult = FALSE;
    }

    if (nullptr != pAckCmdData)
    {
        delete[] pAckCmdData;
        pAckCmdData = nullptr;
    }

    return bResult;
}

BOOL CWirelessModuleProtocol::ReadFirmwarePageCode(
                const DWORD& dwCurComPortNum,
                const USHORT& sPageNum,
                UCHAR* pFirmwarePageCode,
                const USHORT& sPageSize)
{
    LOG_TRACE_METHORD(TEXT("CWirelessModuleProtocol::ReadFirmwarePageCode func."));

    CCommunication* pCommIntf = new CCommunication(dwCurComPortNum,
            CProtocolConst::UPDATE_FIRMWARE_BAUDRATE);

    CReadFirmwareCode pageCodeCmd(pCommIntf,
                                  sPageNum,
                                  sPageSize);
    if (!SendCfgCmd(&pageCodeCmd))
    {
        LOG_ERROR(TEXT("failed to send the cmd of reading firmware page code."));
        return FALSE;
    }

    PBYTE pAckCmdData = nullptr;
    DWORD dwAckCmdDataLen = 0;
    if (!pageCodeCmd.GetAckCmdData(pAckCmdData, dwAckCmdDataLen))
    {
        LOG_ERROR("failed to get the ack cmd data of reading firmware page code.");
        return FALSE;
    }

    memset(pFirmwarePageCode, 0, sPageSize);

    // 拷贝页面代码到输出缓冲区
    memcpy_s(pFirmwarePageCode,
             sPageSize,
             (pAckCmdData + CProtocolConst::FIELD_LEN_PAGE_NUM),
             (dwAckCmdDataLen - CProtocolConst::FIELD_LEN_PAGE_NUM));

    // 由使用者释放内存
    if (nullptr != pAckCmdData)
    {
        delete[] pAckCmdData;
        pAckCmdData = nullptr;
    }

    return TRUE;
}

BOOL CWirelessModuleProtocol::SendUpdateFirmwareEnd(const DWORD& dwCurComPortNum)
{
    LOG_TRACE_METHORD(TEXT("CWirelessModuleProtocol::SendUpdateFirmwareEnd func."));

    CCommunication* pCommIntf = new CCommunication(dwCurComPortNum,
            CProtocolConst::UPDATE_FIRMWARE_BAUDRATE);

    CUpdateFwEnd updateFwCmd(pCommIntf);
    if (!SendCfgCmd(&updateFwCmd))
    {
        LOG_ERROR(TEXT("failed to send the cmd of updating firmware end."));
        return FALSE;
    }

    return TRUE;
}

STATUS_CODE CWirelessModuleProtocol::UpdateFirmware(const DWORD& dwCurComPortNum,
        const UCHAR* pHexFileCode,
        const UINT& uFileSize,
        const BOOL& bFlagStopUpgrade,
        const HWND& hWnd)
{
    LOG_TRACE_METHORD(TEXT("CWirelessModuleProtocol::UpdateFirmware func."));

    while (!bFlagStopUpgrade)
    {
        USHORT sDevID = 0;
        USHORT sPageTotal = 0;
        USHORT sPageSize = 0;
        INT iMaxTryToConnectTimes = 1;
        BOOL bConnected = FALSE;
        BOOL bTips = TRUE;
        while ((!bFlagStopUpgrade) && (!bConnected))
        {
            bConnected = SendConnectDeviceCmd(dwCurComPortNum,
                                              sDevID,
                                              sPageTotal,
                                              sPageSize);

            if (bTips)
            {
                ::PostMessage(hWnd, WM_FIRMWARE_UPGRADE_TIP,
                              (WPARAM)L"正在连接设备...-----------...", 0);
            }
            else
            {
                ::PostMessage(hWnd, WM_FIRMWARE_UPGRADE_TIP,
                              (WPARAM)L"正在连接设备...+++++++++++...", 0);

            }
            bTips = !bTips;
            Sleep(CProtocolConst::INTERVAL_TIME_CONNECT_DEVICE);
        }

        if ((!bFlagStopUpgrade) && bConnected)
        {
            LOG_INFO(L"succeed to connect the device.");
        }

        if ((!bFlagStopUpgrade) && isHexFileGtFlash(uFileSize, sPageTotal, sPageSize))
        {
            return STATUS_UPGRAD_FILE_TOO_BIG;
        }

        ::PostMessage(hWnd, WM_FIRMWARE_UPGRADE_TIP,
                      (WPARAM)L"升级过程中...................", 0);

        // 显示进度条
        ::PostMessage(hWnd, WM_FW_UPGRADE_RESET_PROG_BAR, 0, 0);

        if (!bFlagStopUpgrade)
        {
            STATUS_CODE statusCode = SendFirmwareCode(dwCurComPortNum,
                                     sPageSize, pHexFileCode, uFileSize,
                                     bFlagStopUpgrade, hWnd);
            if (STATUS_FAILED_SEND_FIRMWARE_CODE == statusCode)
            {
                LOG_ERROR(TEXT("failed to send the firmware code."));
                return STATUS_FAILED_SEND_FIRMWARE_CODE;
            }
        }

        Sleep(CProtocolConst::INTERVAL_TIME_READ_WRITE_PAGE);

        if ((!bFlagStopUpgrade) && (!SendUpdateFirmwareEnd(dwCurComPortNum)))
        {
            LOG_ERROR(TEXT("failed to send the updating the firmware finished cmd."));
            return STATUS_FAILED_SEND_UPGRAD_END_CMD;
        }

        if (!bFlagStopUpgrade)
        {
            ::PostMessage(hWnd, WM_FIRMWARE_UPGRADE_TIP,
                          (WPARAM)L"设备软件升级成功!", 0);

            return STATUS_SUCCESS;
        }
    }

    return STATUS_USER_FORCE_STOP_UPGRADE;
}

BOOL CWirelessModuleProtocol::isHexFileGtFlash(const UINT& iHexFileSize,
        const USHORT& sPageTotal,
        const USHORT& sPageSize) const
{
    const UINT iDeviceFlashSize = sPageTotal * sPageSize;
    if (iHexFileSize > iDeviceFlashSize)
    {
        LOG_ERROR(TEXT("firmware file is great than the size of device flash.") <<
                  TEXT(" file size = ") << iHexFileSize << TEXT(" Bytes") <<
                  TEXT(", flash size = ") << iDeviceFlashSize <<
                  TEXT(" Bytes"));

        return TRUE;
    }

    return FALSE;
}

// 暂时不用，保留
BOOL CWirelessModuleProtocol::ConnectDevice(const DWORD& dwCurComPortNum,
        USHORT& sDevID,
        USHORT& sPageTotal,
        USHORT& sPageSize,
        const USHORT& iMaxTryToConnectTimes)
{
    LOG_TRACE_METHORD(TEXT("CWirelessModuleProtocol::ConnectDevice func."));

    USHORT uCurConnectTimes = 0;
    BOOL bConnectedDevice = FALSE;
    do
    {
        bConnectedDevice = SendConnectDeviceCmd(dwCurComPortNum,
                                                sDevID,
                                                sPageTotal,
                                                sPageSize);

        if (!bConnectedDevice)
        {
            Sleep(50);
        }
        else
        {
            break;
        }

        ++uCurConnectTimes;
    }
    while (uCurConnectTimes <= iMaxTryToConnectTimes);

    if (!bConnectedDevice)
    {
        return FALSE;
    }

    return TRUE;
}

STATUS_CODE CWirelessModuleProtocol::SendFirmwareCode(
                const DWORD& dwCurComPortNum,
                const USHORT& sPageSize,
                const BYTE*& pHexFileCode,
                const UINT& uFileSize,
                const BOOL& bFlagStopUpgrade,
                const HWND& hWnd)
{
    LOG_TRACE_METHORD(TEXT("CWirelessModuleProtocol::SendFirmwareCode"));

    // 计算HEX文件包含多少页
    const DWORD sPageTotal = uFileSize / sPageSize;
    const DWORD dwLeftBytes = uFileSize % sPageSize;

    // 设定进度条最大值
    const DWORD dwMaxProgValue = sPageTotal + (dwLeftBytes ? 1 : 0);
    ::PostMessage(hWnd, WM_PROGRESS_MAX_VALUE,
                  (WPARAM)dwMaxProgValue, 0);
    Sleep(100);

    UINT iPageIdx = 0;
    for (iPageIdx = 0; iPageIdx < sPageTotal; ++iPageIdx)
    {
        const BYTE* pCurSendedCode = pHexFileCode + iPageIdx * sPageSize;
        if (!SendAndCheckPageCode(dwCurComPortNum, iPageIdx,
                                  pCurSendedCode, sPageSize))
        {
            return STATUS_FAILED_SEND_FIRMWARE_CODE;
        }

        ::PostMessage(hWnd, WM_PROGRESS_INCREMENT, 0, 0);

        if (bFlagStopUpgrade)
        {
            return STATUS_USER_FORCE_STOP_UPGRADE;
        }
    }

    // 增加最后不足一页数据的发送代码
    const DWORD uFileBytes = sPageSize - dwLeftBytes;
    UCHAR* pszSendedCode = new UCHAR[sPageSize];
    memcpy_s(pszSendedCode,
             sPageSize,
             pHexFileCode + iPageIdx * sPageSize,
             dwLeftBytes);

    Sleep(CProtocolConst::INTERVAL_TIME_READ_WRITE_PAGE);

    // 不足一页数据填充0XFF
    memset(pszSendedCode + dwLeftBytes, 0XFF, sPageSize - dwLeftBytes);
    if (!SendAndCheckPageCode(dwCurComPortNum, iPageIdx,
                              pszSendedCode, sPageSize))
    {
        return STATUS_FAILED_SEND_FIRMWARE_CODE;
    }

    ::PostMessage(hWnd, WM_PROGRESS_INCREMENT, 0, 0);

    return STATUS_SUCCESS;
}

BOOL CWirelessModuleProtocol::SendAndCheckPageCode(
                const DWORD& dwCurComPortNum,
                const USHORT& iPageIdx,
                const UCHAR* pCurPageCode,
                const USHORT& sPageSize)
{
    if (!SendFWPageCode(dwCurComPortNum, iPageIdx, pCurPageCode, sPageSize))
    {
        LOG_ERROR(TEXT("failed to send the page code, pageIdx = ") << iPageIdx);
        return FALSE;
    }

    Sleep(CProtocolConst::INTERVAL_TIME_READ_WRITE_PAGE);

    if (!CheckSentFWPageCode(dwCurComPortNum, iPageIdx, pCurPageCode, sPageSize))
    {
        LOG_ERROR(TEXT("failed to check the sended page code, pageIdx = ") <<
                  iPageIdx);
        return FALSE;
    }

    return TRUE;
}

BOOL CWirelessModuleProtocol::CheckSentFWPageCode(const DWORD& dwCurComPortNum,
        const UINT& iPageIdx,
        const UCHAR* pCurSendedCode,
        const USHORT& sPageSize)
{
    LOG_TRACE_METHORD(TEXT("CWirelessModuleProtocol::CheckSentFWPageCode func."));

    auto_ptr<UCHAR> ReadedPageCode(new UCHAR[sPageSize]);
    if (!ReadFirmwarePageCode(dwCurComPortNum, iPageIdx, ReadedPageCode.get(),
                              sPageSize))
    {
        LOG_ERROR(TEXT("failed to read the sent page code, pageIdx = " <<
                       iPageIdx << TEXT(", pageSize = ") << sPageSize));

        return false;
    }

    // 比较写入和读出的每个字节数据是否相等，不等报错
    for (USHORT iIdx = 0; iIdx < sPageSize; ++iIdx)
    {
        if (pCurSendedCode[iIdx] != ReadedPageCode.get()[iIdx])
        {
            LOG_ERROR(TEXT("write the page code is not equal to read the page code."));
            return FALSE;
        }
    }

    return TRUE;
}