//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Untitled
//  @ File Name : CCmd.cpp
//  @ Date : 2014/10/29 ÐÇÆÚÈý
//  @ Author :
//
//

#include "stdafx.h"
#include "Cmd.h"
#include "../LogSystem.h"

CCmd::CCmd()
{
    memset(m_btCmd, 0, sizeof(m_btCmd));
    m_dwCmdLen = 0;
    m_dwCmdDataLen = 0;
}

CCmd::CCmd(const CCmd& Cmd)
{
    *this = Cmd;
}

CCmd::~CCmd()
{

}

CCmd& CCmd::operator= (const CCmd& Cmd)
{
    if (this == &Cmd)
    {
        return *this;
    }

    memset(m_btCmd, 0, sizeof(m_btCmd));
    memcpy_s(this->m_btCmd, sizeof(m_btCmd), Cmd.m_btCmd, Cmd.m_dwCmdLen);

    this->m_dwCmdLen = Cmd.m_dwCmdLen;
    this->m_dwCmdDataLen = Cmd.m_dwCmdDataLen;

    return *this;
}

DWORD CCmd::GetCmdLen() const
{
    return m_dwCmdLen;
}

PBYTE CCmd::GetCmdBuffer() const
{
    return (PBYTE)&m_btCmd[0];
}

VOID CCmd::SetFrameHead(const BYTE btFrameHead)
{
    m_btCmd[CProtocolConst::OFFSET_FRAME_HEAD] = btFrameHead;
}

BYTE CCmd::GetFrameHead() const
{
    return m_btCmd[CProtocolConst::OFFSET_FRAME_HEAD];
}

VOID CCmd::SetCmdPreserveWord(const BYTE btPreserveWord)
{
    m_btCmd[CProtocolConst::OFFSET_PRESERVE_WORD] = btPreserveWord;
}

BYTE CCmd::GetCmdPreserveWord() const
{
    return m_btCmd[CProtocolConst::OFFSET_PRESERVE_WORD];
}

VOID CCmd::SetCmdWord(const BYTE btCmdWord)
{
    m_btCmd[CProtocolConst::OFFSET_CMD_WORD] = btCmdWord;
}

BYTE CCmd::GetCmdWord() const
{
    return m_btCmd[CProtocolConst::OFFSET_CMD_WORD];
}

BOOL CCmd::SetCmdData(const UCHAR* pCmdData, const DWORD dwDataLen)
{
    if (NULL == pCmdData)
    {
        LOG_ERROR(TEXT("failed to set the cmd's data, pCmdData = NULL."));
        return FALSE;
    }

    if (IsInValidCmdDataLen(dwDataLen))
    {
        LOG_ERROR(TEXT("cmd length : " << dwDataLen << ", error !"));
        return FALSE;
    }

    if (memcpy_s(&m_btCmd[CProtocolConst::OFFSET_CMD_DATA],
                 CProtocolConst::MAX_CMD_DATA_BUF_LEN,
                 pCmdData,
                 dwDataLen))
    {
        LOG_ERROR(TEXT("failed to copy cmd data to cmd buf."));
        return FALSE;
    }

    return TRUE;
}

BOOL CCmd::SetCmdDataLen(const DWORD dwCmdDataLen)
{
    if (IsInValidCmdDataLen(dwCmdDataLen))
    {
        return FALSE;
    }

    m_dwCmdDataLen = dwCmdDataLen;
    m_dwCmdLen = CProtocolConst::FIELD_LEN_FRAME_HEAD +
                 CProtocolConst::FIELD_LEN_PRESERVE_WORD +
                 CProtocolConst::FIELD_LEN_CMD_ID +
                 m_dwCmdDataLen +
                 CProtocolConst::FIELD_LEN_CHECKSUM;

    return TRUE;
}

PBYTE CCmd::GetCmdDataBuffer() const
{
    return (PBYTE)&m_btCmd[CProtocolConst::OFFSET_CMD_DATA];
}

DWORD CCmd::GetCmdDataBufferLen() const
{
    return m_dwCmdDataLen;
}

VOID CCmd::SetCmdChecksum(const BYTE dwChecksum)
{
    m_btCmd[m_dwCmdLen - 1] = dwChecksum;
}

BYTE CCmd::GetChecksum() const
{
    return m_btCmd[m_dwCmdLen - 1];
}

BYTE CCmd::CalcChecksum() const
{
    BYTE btChecksum = 0;
    for (DWORD dwIdx = 0; dwIdx < (m_dwCmdLen - 1); ++dwIdx)
    {
        btChecksum += m_btCmd[dwIdx];
    }

    return btChecksum;
}

BOOL CCmd::IsInValidCmdDataLen(const DWORD dwCmdDataLen)
{
    if (0 == dwCmdDataLen)
    {
        LOG_ERROR(TEXT("cmd length is equal to 0, dwCmdDataLen = 0"));
        return TRUE;
    }

    if (dwCmdDataLen > CProtocolConst::MAX_CMD_DATA_BUF_LEN)
    {
        LOG_ERROR(TEXT("cmd data len is great than ") <<
                  TEXT("cmd data buf length : MAX_CMD_DATA_BUF_LEN =")
                  << CProtocolConst::MAX_CMD_DATA_BUF_LEN);

        return TRUE;
    }

    return FALSE;
}

