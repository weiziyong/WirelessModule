//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Untitled
//  @ File Name : CCfgProtocol.cpp
//  @ Date : 2014/10/29 星期三
//  @ Author :
//
//

#include "stdafx.h"
#include "Cmd.h"
#include "CfgProtocol.h"
#include "AckCmdParser.h"
#include "../LogSystem.h"


CCfgProtocol::CCfgProtocol(CCommIntf* pCommIntf)
{
    ASSERT(NULL != pCommIntf);

    m_pSendCmd = NULL;
    m_pAckCmd = NULL;
    m_pAckCmdParser = NULL;
    m_pCommIntf = pCommIntf;
}

CCfgProtocol::~CCfgProtocol()
{
    if (NULL != m_pSendCmd)
    {
        delete m_pSendCmd;
        m_pSendCmd = NULL;
    }

    if (NULL != m_pAckCmd)
    {
        delete m_pAckCmd;
        m_pAckCmd = NULL;
    }

    if (NULL != m_pCommIntf)
    {
        m_pCommIntf->Close();

        delete m_pCommIntf;
        m_pCommIntf = NULL;
    }

    if (NULL != m_pAckCmdParser)
    {
        delete m_pAckCmdParser;
        m_pAckCmdParser = NULL;
    }
}

BOOL CCfgProtocol::SendCmd()
{
    ASSERT(NULL != m_pCommIntf);

    if (!CreateSendCmd())
    {
        LOG_ERROR(L"failed to create the cmd of sending.");
        return FALSE;
    }

    if (!CreateAckCmd())
    {
        LOG_ERROR(L"failed to create the ack's cmd.");
        return FALSE;
    }

    LogSentCmd();

    if (!m_pCommIntf->SendData(m_pSendCmd->GetCmdBuffer(),
                               m_pSendCmd->GetCmdLen()))
    {
        LOG_ERROR(L"failed to send the cmd.");
        return FALSE;
    }

    DWORD dwReadBytes = 0;
    if ((!m_pCommIntf->ReadData(m_pAckCmd->GetCmdBuffer(),
                                m_pAckCmd->GetCmdLen(),
                                dwReadBytes)) || (0 == dwReadBytes))
    {
        LOG_ERROR(TEXT("failed to receive the ack's cmd."));
        return FALSE;
    }

    LogReceivedAckCmd();

    if (!CreateParser())
    {
        LOG_ERROR(TEXT("failed to create cmd parer."));
        return FALSE;
    }

    if (!IsValidAckCmd())
    {
        LOG_ERROR(TEXT("the ack cmd is error."));
        return FALSE;
    }

    return TRUE;
}

BOOL CCfgProtocol::IsValidAckCmd()
{
    // 区分一般配置应答命令和搜索应答命令
    ASSERT(NULL != m_pAckCmdParser);

    if (!m_pAckCmdParser->IsValidCfgAckCmd())
    {
        LOG_ERROR("The ack's cmd is invalid !");
        return FALSE;
    }

    // 比较应答命令和发送命令是否相同，默认采用配置命令规则；搜索应答命令比较规则在搜索
    // 命令子类中重载实现其规则
    PBYTE pAckCmdData = NULL;
    DWORD dwAckCmdDataLen = 0;
    if (!m_pAckCmdParser->GetCmdData(pAckCmdData, dwAckCmdDataLen) ||
            (m_pSendCmd->GetCmdDataBufferLen() !=
             dwAckCmdDataLen)) // 应答命令的数据长度应该等于发送命令的数据长度
    {
        LOG_ERROR("Read the ack's data is failed , data address : pAckCmdData = 0X" <<
                  std::hex << pAckCmdData <<
                  "; data length : dwAckCmdDataLen = " << dwAckCmdDataLen);
        return FALSE;
    }

    // 应答命令的数据字段值不能够等于0
    if (0X0 == pAckCmdData[0])
    {
        LOG_ERROR("Invalid the ack cmd, the data word value of ack's cmd is equal 0 , error !");
        return FALSE;
    }

    // 比较应答命令是否与发送的配置命令一致，搜索命令则不采用此规则
    if (!IsCmpCmd())
    {
        LOG_ERROR("The ack cmd is not the same as the cmd of sending , error!");
        return FALSE;
    }

    return TRUE;
}

BOOL CCfgProtocol::CreateParser()
{
    ASSERT(NULL != m_pAckCmd);

    // 在接收了应答命令之后，再创建应答命令的解析器
    m_pAckCmdParser = new CAckCmdParser(*m_pAckCmd);
    return TRUE;
}

BOOL CCfgProtocol::IsCmpCmd() const
{
    ASSERT(NULL != m_pSendCmd);
    ASSERT(NULL != m_pAckCmdParser);

    // 比较命令的数据长度是否一致
    if (m_pSendCmd->GetCmdLen() != m_pAckCmdParser->GetCmdLen())
    {
        LOG_ERROR("The length of sending cmd : " << m_pSendCmd->GetCmdLen() <<
                  " is not equal to the ack cmd length : " << m_pAckCmdParser->GetCmdLen());
        return FALSE;
    }

    // 比较每个字段
    PBYTE pSendCmdBuff = m_pSendCmd->GetCmdBuffer();
    PBYTE pAckCmdBuff = m_pAckCmdParser->GetCmdBuffer();

    DWORD dwCmdLen = m_pSendCmd->GetCmdLen();
    DWORD dwChecksumIdx = dwCmdLen - 1;
    for (DWORD dwIdx = 0; dwIdx < dwChecksumIdx; ++dwIdx)
    {
        if ((CProtocolConst::OFFSET_CMD_WORD == dwIdx) || (dwChecksumIdx == dwIdx))
        {
            continue;
        }

        if (pSendCmdBuff[dwIdx] != pAckCmdBuff[dwIdx])
        {
            LOG_ERROR("The cmd's word value of send cmd: " << pSendCmdBuff[dwIdx] <<
                      "is not equal to the cmd's word of ack cmd : " << pAckCmdBuff[dwIdx] <<
                      " , index value :" << dwIdx);
            return FALSE;
        }
    }

    return TRUE;
}

void CCfgProtocol::LogSentCmd() const
{
    PBYTE pSendCmdBuffer = m_pSendCmd->GetCmdBuffer();
    CString strSendCmd = TEXT("");
    for (size_t iIdx = 0; iIdx < m_pSendCmd->GetCmdLen(); iIdx++)
    {
        CString strByte = TEXT("");
        strByte.Format(TEXT("%02X "), pSendCmdBuffer[iIdx]);

        strSendCmd += strByte;
    }

    LOG_INFO(L"Sent cmd : " << (PCTSTR)strSendCmd);
}

void CCfgProtocol::LogReceivedAckCmd() const
{
    PBYTE pAckCmdBuffer = m_pAckCmd->GetCmdBuffer();
    CString strReceivedAckCmd = TEXT("");
    for (size_t iIdxAckCmd = 0; iIdxAckCmd < m_pAckCmd->GetCmdLen(); ++iIdxAckCmd)
    {
        CString strByte = TEXT("");
        strByte.Format(TEXT("%02X "), pAckCmdBuffer[iIdxAckCmd]);
        strReceivedAckCmd += strByte;
    }

    LOG_INFO(TEXT("Received the ack's cmd from device : ") <<
             (PCTSTR)strReceivedAckCmd);
}

BOOL CCfgProtocol::GetAckCmdData(PBYTE& pAckCmdData, DWORD& dwAckCmdDataLen) const
{
    ASSERT(NULL != m_pAckCmdParser);

    if (NULL == m_pAckCmdParser)
    {
        LOG_ERROR("m_pAckCmdParser == NULL.");
        return FALSE;
    }

    if (!m_pAckCmdParser->GetCmdData(pAckCmdData, dwAckCmdDataLen))
    {
        LOG_ERROR("failed to get the data of ack's cmd.");
        return FALSE;
    }

    return TRUE;
}




